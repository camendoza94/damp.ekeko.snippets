Template group with 3 templates:
	[1] - class with template method itself
	[2] - class with abstract method being called
	[3] - class with overridden method

Template-method steps:

// Removing irrelevant stuff..

1 Remove javadoc in each template (3 x erase-template)

2 Replace class name by wildcard in [1]

3 Remove irrelevant methods in [1]

4 Add match set around the class body

5 Remove irrelevant statements in generate method in [1]

6 Add match|set around generate-method body in [1]

7?? Pull up expression of prepare() call in assignment stmt

8 Remove abstract from class decl in [2]
	+ add match|set to modifiers (apparently doesn't match otherwise..)

9 Remove irrelevant methods in [2]

10 match|set to body in [2]

11 Remove irrelevant methods in [3]

12 add match|set to class body [3]

// Abstracting away names

13 Replace generate methodname in [1]

14 Replace generate params & return type by wildcard

15 Replace class name by meta-var in [2]

16 Replace method name by meta-var in []

17 Abstract away prepare() 's name and formal params in [2] (replace by meta-var + replace by wildcard on params and return type)

.. hmm, interesting .. at this point we're getting more matches than needed; we're only going to narrow it back down later on .. how is our evolution-fitness-function going to deal with this?
maybe the evolution thing should first add refinement ops before generalizing as much as possible?

18 Abstract class names + body in [3] (replace by wildcard and by meta-variable)

.. hm hold on, maybe we don't need the class definitions for [2] and [3] after all?

---

20 add equals ?amethod to method declaration in [2]

21 add overrides in [3]

22 add equals ?call to prepare() call in [1]

23 add invoked-by around method decl in [2]


?
	How to pull up an expression?
	i.e. turn bla = call(); into call()@[child+]

	Add-directive: pull-up-and-add-child+ ?